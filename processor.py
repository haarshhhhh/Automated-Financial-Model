# -*- coding: utf-8 -*-
"""processsor.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1D8qXpbrtxSMOzuUPEbsbk2Li_KbvwZzr
"""

import numpy as np

import pandas as pd
# Slice the DataFrame to get the P&L section using fixed row numbers
# Based on previous successful execution, assuming P&L data is within rows 14 to 30
pl_df = df.iloc[14:30].copy()

# 2. Set the first row as the header
pl_df.columns = pl_df.iloc[0]

# 3. Remove the first row (which is now the header)
pl_df = pl_df.iloc[1:].copy()

# 4. Rename the first column to 'Particulars'
pl_df = pl_df.rename(columns={pl_df.columns[0]: 'Particulars'})

# Get all columns except the first one
date_cols = pl_df.columns[1:]

# Attempt to convert column names to numeric, turning errors into 'NaN'
numeric_cols = pd.to_numeric(date_cols, errors='coerce')

# Convert numeric values to datetime; 'NaN' will become 'NaT' (Not a Time)
datetime_cols = pd.to_datetime(numeric_cols, unit='D', origin='1899-12-30')

# Create new names: format if it's a valid date, otherwise keep the original name
new_colnames = [
    dt.strftime('%b-%Y') if pd.notna(dt) else orig_name
    for dt, orig_name in zip(datetime_cols, date_cols)
]

# Create a mapping from old column names to the new ones
rename_dict = dict(zip(date_cols, new_colnames))

# Rename the columns using the dictionary
pl_df = pl_df.rename(columns=rename_dict)


# Display the resulting dataframe to check
print(pl_df)

bs_df = df.iloc[54:71].copy()

# 2. Set the first row as the header
bs_df.columns = bs_df.iloc[0]

# 3. Remove the first row (which is now the header)
bs_df = bs_df.iloc[1:].copy() # Added .copy() to avoid SettingWithCopyWarning

# 4. Keep and rename the first column to 'Particulars'
bs_df = bs_df.rename(columns={bs_df.columns[0]: 'Particulars'})

# Get all columns except the first one
date_cols = bs_df.columns[1:]

# Attempt to convert column names to numeric, turning errors into 'NaN'
numeric_cols = pd.to_numeric(date_cols, errors='coerce')

# Convert numeric values to datetime; 'NaN' will become 'NaT' (Not a Time)
datetime_cols = pd.to_datetime(numeric_cols, unit='D', origin='1899-12-30')

# Create new names: format if it's a valid date, otherwise keep the original name
new_colnames = [
    dt.strftime('%b-%Y') if pd.notna(dt) else orig_name
    for dt, orig_name in zip(datetime_cols, date_cols)
]

# Create a mapping from old column names to the new ones
rename_dict = dict(zip(date_cols, new_colnames))

# Rename the columns using the dictionary
bs_df = bs_df.rename(columns=rename_dict)


# Display the resulting dataframe to check
print(bs_df)

qt_df = df.iloc[39:49].copy()

# 2. Set the first row as the header
qt_df.columns = qt_df.iloc[0]

# 3. Remove the first row (which is now the header)
qt_df = qt_df.iloc[1:]

# 4. Rename the first column to 'Particulars'
qt_df = qt_df.rename(columns={qt_df.columns[0]: 'Particulars'})

# Get all columns except the first one
date_cols = qt_df.columns[1:]

# Attempt to convert column names to numeric, turning errors into 'NaN'
numeric_cols = pd.to_numeric(date_cols, errors='coerce')

# Convert numeric values to datetime; 'NaN' will become 'NaT' (Not a Time)
datetime_cols = pd.to_datetime(numeric_cols, unit='D', origin='1899-12-30')

# Create new names: format if it's a valid date, otherwise keep the original name
new_colnames = [
    dt.strftime('%b-%Y') if pd.notna(dt) else orig_name
    for dt, orig_name in zip(datetime_cols, date_cols)
]

# Create a mapping from old column names to the new ones
rename_dict = dict(zip(date_cols, new_colnames))

# Rename the columns using the dictionary
qt_df = qt_df.rename(columns=rename_dict)


# Display the resulting dataframe to check
print(qt_df)

# Assuming cf_df is already defined from previous steps

# 1. Set 'Particulars' column as index
# Use integer position to set 'Particulars' as index
if not cf_df.empty and 'Particulars' in cf_df.columns:
    # Temporarily store the 'Particulars' column to ensure it's handled correctly
    particulars_col = cf_df['Particulars']
    # Drop 'Particulars' column and keep the rest
    temp_df = cf_df.drop(columns=['Particulars'])
    # Set the 'Particulars' column back as the index
    cf_df = temp_df
    cf_df.index = particulars_col
    cf_df.index.name = 'Particulars' # Set the index name
elif not cf_df.empty:
    # Fallback if 'Particulars' is already the index or missing
    # Assuming the first column is intended to be the index if 'Particulars' column is not found
    cf_df = cf_df.set_index(cf_df.columns[0])
    cf_df.index.name = 'Particulars' # Set the index name


# 2. Convert date columns to datetime objects
# Assuming columns other than the index are date columns
date_cols = cf_df.columns
# Check if columns are already datetime objects before converting
if not pd.api.types.is_datetime64_any_dtype(date_cols):
    cf_df.columns = pd.to_datetime(date_cols, errors='coerce')

# 3. Convert all data columns to numeric, handling errors
cf_df = cf_df.apply(pd.to_numeric, errors='coerce')

# Display the cleaned and structured DataFrame
display(cf_df)

# Assuming pl_df, balance_df are already defined.

# Get the formatted date column names from pl_df (these should be strings like 'Mar-YYYY')
date_column_names = pl_df.columns[1:]

# Extract the numerical values for calculations, converting to numeric and handling errors
def safe_numeric(data):
    if isinstance(data, pd.Series):
        return pd.to_numeric(data, errors='coerce')
    elif isinstance(data, pd.DataFrame):
        return data.apply(pd.to_numeric, errors='coerce')
    else:
        return pd.to_numeric(data, errors='coerce')

# Select the 'Sales' row using the exact string provided by the user
sales_row = pl_df[pl_df['Particulars'] == 'Sales']
IS_df = pd.DataFrame(safe_numeric(sales_row[date_column_names]).iloc[0]).T
IS_df.columns = date_column_names # Set column names to formatted date strings
IS_df.index = ['Sales']


# Calculate Sales Growth %
IS_df.loc['Sales Growth %', date_column_names] = IS_df.loc['Sales', date_column_names].pct_change() * 100

# Select relevant rows for COGS calculation using the exact strings provided by the user
raw_material_cost_row = pl_df[pl_df['Particulars'] == 'Raw Material Cost']
change_in_inventory_row = pl_df[pl_df['Particulars'] == 'Change in Inventory']
power_and_fuel_row = pl_df[pl_df['Particulars'] == 'Power and Fuel']
other_mfr_exp_row = pl_df[pl_df['Particulars'] == 'Other Mfr. Exp']
employee_cost_row = pl_df[pl_df['Particulars'] == 'Employee Cost']

# --- Debugging Prints for COGS Component Rows and Numeric Conversion ---
print("Raw Material Cost Row (selected):")
print(raw_material_cost_row)
if not raw_material_cost_row.empty:
    raw_material_cost_numeric = safe_numeric(raw_material_cost_row[date_column_names].iloc[0])
    print("Raw Material Cost (numeric):", raw_material_cost_numeric)
else:
    print("Raw Material Cost row is empty.")

print("\nChange in Inventory Row (selected):")
print(change_in_inventory_row)
if not change_in_inventory_row.empty:
    change_in_inventory_numeric = safe_numeric(change_in_inventory_row[date_column_names].iloc[0])
    print("Change in Inventory (numeric):", change_in_inventory_numeric)
else:
     print("Change in Inventory row is empty.")

print("\nPower and Fuel Row (selected):")
print(power_and_fuel_row)
if not power_and_fuel_row.empty:
    power_and_fuel_numeric = safe_numeric(power_and_fuel_row[date_column_names].iloc[0])
    print("Power and Fuel (numeric):", power_and_fuel_numeric)
else:
    print("Power and Fuel row is empty.")

print("\nOther Mfr. Exp Row (selected):")
print(other_mfr_exp_row)
if not other_mfr_exp_row.empty:
    other_mfr_exp_numeric = safe_numeric(other_mfr_exp_row[date_column_names].iloc[0])
    print("Other Mfr. Exp (numeric):", other_mfr_exp_numeric)
else:
    print("Other Mfr. Exp row is empty.")

print("\nEmployee Cost Row (selected):")
print(employee_cost_row)
if not employee_cost_row.empty:
    employee_cost_numeric = safe_numeric(employee_cost_row[date_column_names].iloc[0])
    print("Employee Cost (numeric):", employee_cost_numeric)
else:
    print("Employee Cost row is empty.")


# Calculate COGS
cogs_calculation = pd.Series(0, index=date_column_names, dtype=float) # Initialize with zeros

if not raw_material_cost_row.empty:
    raw_material_cost_numeric = safe_numeric(raw_material_cost_row[date_column_names].iloc[0])
    # Add only if not NaN
    cogs_calculation = cogs_calculation.add(raw_material_cost_numeric, fill_value=0)


if not change_in_inventory_row.empty:
    change_in_inventory_numeric = safe_numeric(change_in_inventory_row[date_column_names].iloc[0])
    # Subtract only if not NaN
    cogs_calculation = cogs_calculation.sub(change_in_inventory_numeric, fill_value=0)


if not power_and_fuel_row.empty:
    power_and_fuel_numeric = safe_numeric(power_and_fuel_row[date_column_names].iloc[0])
    # Add only if not NaN
    cogs_calculation = cogs_calculation.add(power_and_fuel_numeric, fill_value=0)


if not other_mfr_exp_row.empty:
    other_mfr_exp_numeric = safe_numeric(other_mfr_exp_row[date_column_names].iloc[0])
    # Add only if not NaN
    cogs_calculation = cogs_calculation.add(other_mfr_exp_numeric, fill_value=0)


if not employee_cost_row.empty:
    employee_cost_numeric = safe_numeric(employee_cost_row[date_column_names].iloc[0])
    # Add only if not NaN
    cogs_calculation = cogs_calculation.add(employee_cost_numeric, fill_value=0)

IS_df.loc['COGS', date_column_names] = cogs_calculation

# --- Debugging Print for COGS Calculation Result ---
print("\nCOGS Calculation Result (before assignment):")
print(cogs_calculation)


# Calculate COGS % Sales
IS_df.loc['COGS % Sales', date_column_names] = (IS_df.loc['COGS', date_column_names] / IS_df.loc['Sales', date_column_names]) * 100

# Calculate Gross Profit
gross_profit_calculation = IS_df.loc['Sales', date_column_names] - IS_df.loc['COGS', date_column_names]
IS_df.loc['Gross Profit', date_column_names] = gross_profit_calculation


# Calculate Gross Profit % Sales
IS_df.loc['Gross Profit % Sales', date_column_names] = (IS_df.loc['Gross Profit', date_column_names] / IS_df.loc['Sales', date_column_names]) * 100

# Select relevant row for Selling and General Expenses using exact string
selling_and_admin = pl_df[pl_df['Particulars'] == 'Selling and admin']

# Calculate Selling and General Expenses
IS_df.loc['Selling and General Expenses', date_column_names] = safe_numeric(selling_and_admin[date_column_names].iloc[0])

# Select relevant rows for EBITDA calculation using exact strings
profit_before_tax = pl_df[pl_df['Particulars'] == 'Profit before tax']
interest_pl = pl_df[pl_df['Particulars'] == 'Interest']
depreciation_pl = pl_df[pl_df['Particulars'] == 'Depreciation']


# Calculate EBITDA
IS_df.loc['EBITDA', date_column_names] = (
    safe_numeric(profit_before_tax[date_column_names]).iloc[0] + safe_numeric(interest_pl[date_column_names]).iloc[0] + safe_numeric(depreciation_pl[date_column_names]).iloc[0]
)

# Calculate EBITDA % sales
IS_df.loc['EBITDA % sales', date_column_names] = (IS_df.loc['EBITDA', date_column_names] / IS_df.loc['Sales', date_column_names]) * 100

# Calculate Interest
IS_df.loc['Interest', date_column_names] = safe_numeric(interest_pl[date_column_names].iloc[0])

# Calculate Interest % sales
IS_df.loc['Interest % sales', date_column_names] = (IS_df.loc['Interest', date_column_names] / IS_df.loc['Sales', date_column_names]) * 100

# Calculate Depreciation
IS_df.loc['Depreciation', date_column_names] = safe_numeric(depreciation_pl[date_column_names].iloc[0])

# Calculate Depreciation % sales
IS_df.loc['Depreciation % sales', date_column_names] = (IS_df.loc['Depreciation', date_column_names] / IS_df.loc['Sales', date_column_names]) * 100

# Calculate EBIT
IS_df.loc['EBIT', date_column_names] = IS_df.loc['EBITDA', date_column_names] - IS_df.loc['Depreciation', date_column_names]

# Calculate Earning Before Tax using exact string
EBT_row = pl_df[pl_df['Particulars'] == 'Profit before tax'] # Use Profit before tax for EBT
IS_df.loc['Earning Before Tax', date_column_names] = safe_numeric(EBT_row[date_column_names].iloc[0])

# Calculate EBT % sales
IS_df.loc['EBT % sales', date_column_names] = (IS_df.loc['Earning Before Tax', date_column_names] / IS_df.loc['Sales', date_column_names]) * 100

# Select relevant row for Tax using exact string
tax_row = pl_df[pl_df['Particulars'] == 'Tax']

# Calculate Tax
IS_df.loc['Tax', date_column_names] = safe_numeric(tax_row[date_column_names].iloc[0])


# Calculate Effective Tax Rate, handling division by zero
IS_df.loc['Effective Tax Rate', date_column_names] = (IS_df.loc['Tax', date_column_names] / IS_df.loc['Earning Before Tax', date_column_names].replace(0, pd.NA)) * 100

# Select relevant row for Net Profit using exact string
net_profit_row = pl_df[pl_df['Particulars'] == 'Net profit']

# Calculate Net Profit
IS_df.loc['Net Profit', date_column_names] = safe_numeric(net_profit_row[date_column_names].iloc[0])


# Calculate Net Margin
IS_df.loc['Net Margin', date_column_names] = (IS_df.loc['Net Profit', date_column_names] / IS_df.loc['Sales', date_column_names]) * 100

# Balance Sheet and Combined Calculations

# Select relevant row for No. of Equity Shares from bs_df using exact string
equity_shares_row = bs_df[bs_df['Particulars'] == 'No. of Equity Shares']

# Calculate No. of equity Shares using the date column names from pl_df (formatted strings)
IS_df.loc['No. of equity Shares', date_column_names] = safe_numeric(equity_shares_row[date_column_names]).iloc[0]

# Calculate EPS
IS_df.loc['EPS', date_column_names] = (IS_df.loc['Net Profit', date_column_names] * 1e7) / IS_df.loc['No. of equity Shares', date_column_names]

# Select relevant row for Dividend Amount from pl_df using exact string
dividend_amount_row = pl_df[pl_df['Particulars'] == 'Dividend Amount']

# Calculate Dividend Per Share
IS_df.loc['Dividend Per Share', date_column_names] = safe_numeric(dividend_amount_row[date_column_names]).iloc[0] / IS_df.loc['No. of equity Shares', date_column_names]

# Calculate Dividend payout ratio, handling division by zero
IS_df.loc['Dividend payout ratio', date_column_names] = (safe_numeric(dividend_amount_row[date_column_names]).iloc[0] / IS_df.loc['Net Profit', date_column_names].replace(0, pd.NA)) * 100

print("✅ IS Calculations complete.")


# --- ADD THIS SECTION FOR FORMATTING ---

# Define which rows are currency, percentage, or a count
currency_rows = [
    'Sales', 'COGS', 'Gross Profit', 'Selling and General Expenses', 'EBITDA',
    'Interest', 'Depreciation', 'EBIT', 'Earning Before Tax', 'Tax', 'Net Profit',
    'EPS', 'Dividend Per Share'
]
percentage_rows = [
    'Sales Growth %', 'COGS % Sales', 'Gross Profit % Sales',
    'S&G expenses % sales', 'EBITDA % sales', 'Interest % sales',
    'Depreciation % sales', 'EBT % sales', 'Effective Tax Rate', 'Net Margin',
    'Dividend payout ratio'
]
count_rows = ['No. of equity Shares']

# Create the formatter dictionary
formatter = {}
for row in currency_rows:
    formatter[row] = '₹{:,.2f}'
for row in percentage_rows:
    formatter[row] = '{:.2f}%'
for row in count_rows:
    formatter[row] = '{:,.0f}'

# Apply the formatting to the DataFrame for display
# Using na_rep='-' will display a dash for empty values (like the first year's growth %)
styled_df = IS_df.style.format(formatter, na_rep="-").set_properties(**{'text-align': 'right'})

display(styled_df)

# Convert all data columns to numeric type, handling any potential errors
# Separate the index column and data columns before numeric conversion

if not bs_df.empty:
    # Assuming the first column is the 'Particulars' column
    particulars_col = bs_df.iloc[:, 0]
    # Select all columns from the second column onwards and convert to numeric
    data_cols = bs_df.iloc[:, 1:].apply(pd.to_numeric, errors='coerce')

    # Combine the 'Particulars' column as index with the numeric data columns
    raw_df = data_cols
    raw_df.index = particulars_col
    raw_df.index.name = 'Particulars' # Set the index name

else:
    # Handle case where bs_df is empty
    raw_df = pd.DataFrame()


# Clean up date column headers to be more readable (ensure they are strings)
# Convert datetime objects to 'Mar YYYY' strings
# Check if columns are datetime objects before formatting
if not raw_df.empty and pd.api.types.is_datetime64_any_dtype(raw_df.columns):
  raw_df.columns = pd.to_datetime(raw_df.columns).strftime('Mar %Y')
date_cols = raw_df.columns

# 3. Define the structure for the new Balance Sheet
new_index = [
    'Equity Share Capital', 'Reserves', 'Borrowings', 'Other Liabilities',
    'Total Liabilities',
    'Fixed Asset Net Block', 'Capital Work in Progress', 'Investments', 'Other Assets',
    'Total Non Current Assets',
    'Receivables', 'Inventory', 'Cash & Bank',
    'Total Current Assets',
    'Total Assets',
    'CHECK'
]
balance_sheet = pd.DataFrame(index=new_index, columns=date_cols)

# 4. Populate the new DataFrame with data and calculations
# --- Liabilities and Equity ---
# Check if index labels exist in raw_df before accessing
if 'Equity Share Capital' in raw_df.index:
    balance_sheet.loc['Equity Share Capital', date_cols] = raw_df.loc['Equity Share Capital', date_cols]
if 'Reserves' in raw_df.index:
    balance_sheet.loc['Reserves', date_cols] = raw_df.loc['Reserves', date_cols]
if 'Borrowings' in raw_df.index:
    balance_sheet.loc['Borrowings', date_cols] = raw_df.loc['Borrowings', date_cols]
if 'Other Liabilities' in raw_df.index:
    balance_sheet.loc['Other Liabilities', date_cols] = raw_df.loc['Other Liabilities', date_cols]

# Calculate Total Liabilities if components are available
if all(item in balance_sheet.index for item in ['Equity Share Capital', 'Reserves', 'Borrowings', 'Other Liabilities']):
    balance_sheet.loc['Total Liabilities', date_cols] = balance_sheet.loc[['Equity Share Capital', 'Reserves', 'Borrowings', 'Other Liabilities'], date_cols].sum()


# --- Non-Current Assets ---
# Check if index labels exist in raw_df before accessing
if 'Net Block' in raw_df.index:
    balance_sheet.loc['Fixed Asset Net Block', date_cols] = raw_df.loc['Net Block', date_cols] # Renamed from 'Net Block'
if 'Capital Work in Progress' in raw_df.index:
    balance_sheet.loc['Capital Work in Progress', date_cols] = raw_df.loc['Capital Work in Progress', date_cols]
if 'Investments' in raw_df.index:
    balance_sheet.loc['Investments', date_cols] = raw_df.loc['Investments', date_cols]

# Calculate Other Assets if components are available
if all(item in raw_df.index for item in ['Other Assets', 'Receivables', 'Inventory', 'Cash & Bank']):
    balance_sheet.loc['Other Assets', date_cols] = safe_numeric(raw_df.loc['Other Assets', date_cols]) - safe_numeric(raw_df.loc[['Receivables', 'Inventory', 'Cash & Bank'], date_cols].sum())

# Calculate Total Non Current Assets if components are available
if all(item in balance_sheet.index for item in ['Fixed Asset Net Block', 'Capital Work in Progress', 'Investments', 'Other Assets']):
    balance_sheet.loc['Total Non Current Assets', date_cols] = balance_sheet.loc[['Fixed Asset Net Block', 'Capital Work in Progress', 'Investments', 'Other Assets'], date_cols].sum()


# --- Current Assets ---
# Check if index labels exist in raw_df before accessing
if 'Receivables' in raw_df.index:
    balance_sheet.loc['Receivables', date_cols] = raw_df.loc['Receivables', date_cols]
if 'Inventory' in raw_df.index:
    balance_sheet.loc['Inventory', date_cols] = raw_df.loc['Inventory', date_cols]
if 'Cash & Bank' in raw_df.index:
    balance_sheet.loc['Cash & Bank', date_cols] = raw_df.loc['Cash & Bank', date_cols]

# Calculate Total Current Assets if components are available
if all(item in balance_sheet.index for item in ['Receivables', 'Inventory', 'Cash & Bank']):
    balance_sheet.loc['Total Current Assets', date_cols] = balance_sheet.loc[['Receivables', 'Inventory', 'Cash & Bank'], date_cols].sum()

# --- Total Assets and Final Check ---
# Calculate Total Assets if components are available
if all(item in balance_sheet.index for item in ['Total Non Current Assets', 'Total Current Assets']):
    balance_sheet.loc['Total Assets', date_cols] = balance_sheet.loc['Total Non Current Assets', date_cols] + balance_sheet.loc['Total Current Assets', date_cols]

# Explicitly convert to numeric for the comparison and check if components are available
if all(item in balance_sheet.index for item in ['Total Liabilities', 'Total Assets']):
    balance_sheet.loc['CHECK', date_cols] = np.isclose(pd.to_numeric(balance_sheet.loc['Total Liabilities', date_cols], errors='coerce'), pd.to_numeric(balance_sheet.loc['Total Assets', date_cols], errors='coerce'))


# 5. Apply currency formatting for a clean display
# Check if balance_sheet is not empty before formatting
if not balance_sheet.empty:
    styled_balance_sheet = balance_sheet.style.format('₹{:,.2f}', na_rep="-")

    # Display the final, structured Balance Sheet
    display(styled_balance_sheet)
else:
    print("Balance Sheet DataFrame is empty after processing.")

# 2. CALCULATE FINANCIAL RATIOS
# ==============================================================================
# Get the formatted string column names from IS_df
date_cols = IS_df.columns

# Explicitly rename columns of balance_sheet to match the formatted string date_cols
# Assuming the order of columns in balance_sheet (after 'Particulars' which is the index)
# corresponds to the order of dates in date_cols
if 'Particulars' in balance_sheet.columns:
    # If 'Particulars' is still a column, drop it before renaming
    balance_sheet_for_ratios = balance_sheet.drop(columns=['Particulars']).copy()
else:
    balance_sheet_for_ratios = balance_sheet.copy()

# Ensure the number of columns matches before renaming
if len(balance_sheet_for_ratios.columns) == len(date_cols):
    balance_sheet_for_ratios.columns = date_cols
else:
    # If column count doesn't match, try to align based on date values if possible
    # This is a fallback and might need further adjustment based on data
    try:
        # Attempt to convert balance_sheet columns to datetime and then format as strings
        bs_cols_formatted = pd.to_datetime(balance_sheet_for_ratios.columns).strftime('%b-%Y')
        if list(bs_cols_formatted) == list(date_cols):
             balance_sheet_for_ratios.columns = date_cols
        else:
            print("Warning: Column names in balance_sheet do not match IS_df after formatting attempt.")
            # Fallback to original columns if formatting doesn't align
            balance_sheet_for_ratios.columns = balance_sheet.columns
    except Exception as e:
        print(f"Error formatting balance_sheet columns: {e}")
        # Fallback to original columns if formatting fails
        balance_sheet_for_ratios.columns = balance_sheet.columns


ratios_df = pd.DataFrame(columns=date_cols)

# --- Growth, Margin & Expense Ratios ---
# Use date_cols for both IS_df and balance_sheet_for_ratios access
ratios_df.loc['Sales Growth', date_cols] = IS_df.loc['Sales', date_cols].pct_change() * 100
ratios_df.loc['EBITDA Growth', date_cols] = IS_df.loc['EBITDA', date_cols].pct_change() * 100
ratios_df.loc['EBIT Growth', date_cols] = IS_df.loc['EBIT', date_cols].pct_change() * 100
ratios_df.loc['Net Profit Growth', date_cols] = IS_df.loc['Net Profit', date_cols].pct_change() * 100
total_dividend = IS_df.loc['Dividend Per Share', date_cols] * IS_df.loc['No. of equity Shares', date_cols]
ratios_df.loc['Dividend Growth', date_cols] = total_dividend.pct_change() * 100
ratios_df.loc['Gross Margin', date_cols] = (IS_df.loc['Gross Profit', date_cols] / IS_df.loc['Sales', date_cols]) * 100
ratios_df.loc['EBITDA Margin', date_cols] = (IS_df.loc['EBITDA', date_cols] / IS_df.loc['Sales', date_cols]) * 100
ratios_df.loc['EBIT Margin (Operating Margin)', date_cols] = (IS_df.loc['EBIT', date_cols] / IS_df.loc['Sales', date_cols]) * 100
ratios_df.loc['Net Profit Margin', date_cols] = (IS_df.loc['Net Profit', date_cols] / IS_df.loc['Sales', date_cols]) * 100

# --- Return Ratios ---
# Use date_cols for both IS_df and balance_sheet_for_ratios access
shareholder_equity = balance_sheet_for_ratios.loc['Equity Share Capital', date_cols] + balance_sheet_for_ratios.loc['Reserves', date_cols]
capital_employed = balance_sheet_for_ratios.loc['Total Assets', date_cols] - balance_sheet_for_ratios.loc['Other Liabilities', date_cols]
ratios_df.loc['Return on Equity (ROE)', date_cols] = (IS_df.loc['Net Profit', date_cols] / shareholder_equity) * 100
ratios_df.loc['Return on Capital Employed (ROCE)', date_cols] = (IS_df.loc['EBIT', date_cols] / capital_employed) * 100
dividend_payout_ratio = (total_dividend / 1e7) / IS_df.loc['Net Profit', date_cols]
ratios_df.loc['Self Sustained Growth Rate', date_cols] = ratios_df.loc['Return on Equity (ROE)', date_cols] * (1 - dividend_payout_ratio)
ratios_df.loc['Interest Coverage Ratio', date_cols] = IS_df.loc['EBIT', date_cols] / IS_df.loc['Interest', date_cols]

# --- Turnover Ratios & Cash Conversion Cycle ---
# Use date_cols for both IS_df and balance_sheet_for_ratios access
ratios_df.loc['Debtor Turnover Ratio', date_cols] = IS_df.loc['Sales', date_cols] / balance_sheet_for_ratios.loc['Receivables', date_cols]
ratios_df.loc['Creditor Turnover Ratio', date_cols] = IS_df.loc['COGS', date_cols] / balance_sheet_for_ratios.loc['Other Liabilities', date_cols]
ratios_df.loc['Inventory Turnover Ratio', date_cols] = IS_df.loc['COGS', date_cols] / balance_sheet_for_ratios.loc['Inventory', date_cols]
ratios_df.loc['Fixed Asset Turnover Ratio', date_cols] = IS_df.loc['Sales', date_cols] / balance_sheet_for_ratios.loc['Fixed Asset Net Block', date_cols]
ratios_df.loc['Debtor Days', date_cols] = 365 / ratios_df.loc['Debtor Turnover Ratio', date_cols]
ratios_df.loc['Payable Days', date_cols] = 365 / ratios_df.loc['Creditor Turnover Ratio', date_cols]
ratios_df.loc['Inventory Days', date_cols] = 365 / ratios_df.loc['Inventory Turnover Ratio', date_cols]
ratios_df.loc['Cash Conversion Cycle (Days)', date_cols] = ratios_df.loc['Debtor Days', date_cols] + ratios_df.loc['Inventory Days', date_cols] - ratios_df.loc['Payable Days', date_cols]

# --- COMMENTED OUT: Cash Flow Ratios (due to persistent errors) ---
# # Select the row where 'Particulars' is 'Cash from Operating Activity'
# cfo_row_index = cf_df[cf_df['Particulars'] == 'Cash from Operating Activity'].index[0]
# # Get the integer column indices for the date columns by iterating through cf_df columns
# cf_date_col_indices = [i for i, col in enumerate(cf_df.columns) if isinstance(col, pd.Timestamp)]

# # Access the raw values from the underlying numpy array using iloc with integer indices
# cfo_values_array = cf_df.iloc[cfo_row_index, cf_date_col_indices].values.flatten()

# # Manually convert each value to numeric using float(), handling errors
# cfo_numeric_list = []
# for val in cfo_values_array:
#     try:
#         cfo_numeric_list.append(float(val))
#     except (ValueError, TypeError):
#         cfo_numeric_list.append(np.nan) # Use numpy.nan for missing numeric values

# # Create a Pandas Series from the numeric values and date_cols as the index
# cfo = pd.Series(cfo_numeric_list, index=date_cols)

# total_debt = balance_sheet_for_ratios.loc['Borrowings', date_cols]
# ratios_df.loc['CFO/Sales', date_cols] = (cfo / IS_df.loc['Sales', date_cols]) * 100
# ratios_df.loc['CFO/Total Assets', date_cols] = (cfo / balance_sheet_for_ratios.loc['Total Assets', date_cols]) * 100
# ratios_df.loc['CFO/Total Debt', date_cols] = (cfo / total_debt) * 100


# ==============================================================================
# 3. DISPLAY THE RESULTS
# ==============================================================================
print("Complete Ratio Analysis")
styled_ratios = ratios_df.style.format("{:,.2f}", na_rep="-")